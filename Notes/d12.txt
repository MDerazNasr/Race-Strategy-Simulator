DAY 12 — Observation Engineering (Part B) + Vehicle Dynamics (Part A)
=======================================================================
Week 3 (opening) | Physics upgrade + richer observation space

-----------------------------------------------------------------------
SESSION GOAL
-----------------------------------------------------------------------
1. Part B — Observation Engineering:
   Expand the observation vector from 6D to 9D by adding:
     - Two additional curvature lookahead samples (15 and 30 wpts)
     - Lap progress as a continuous position signal

2. Part A — Vehicle Dynamics:
   Replace the kinematic bicycle Car with a new DynamicCar class
   implementing the full dynamic bicycle model with Pacejka tyre forces.
   Add the two new dynamic states (v_y, r) to the observation, giving
   a final 11D obs vector.

3. Re-collect expert data, retrain BC, retrain PPO, run evaluation.

-----------------------------------------------------------------------
NEW FILES / CHANGES
-----------------------------------------------------------------------
env/car_model.py     — Added DynamicCar class (dynamic bicycle model)
env/f1_env.py        — Import DynamicCar, swap Car → DynamicCar,
                       obs 6D → 11D, rewrite get_obs(), updated info dict
rl/bc_init_policy.py — state_dim now auto-detected from saved weights
rl/evaluate.py       — state_dim auto-detected; removed stale 6D PPO
                       Scratch from comparison

New artifacts:
  bc/expert_data.npz       (overwritten: 36,456 samples, 11D)
  bc/bc_policy.pt          (overwritten: BC trained on 11D obs)
  bc/bc_policy_final.pt    (overwritten: same)
  rl/ppo_bc_stable.zip     (overwritten: PPO trained on 11D obs)
  runs/ppo_bc_stable/      (TensorBoard logs)
  plots/eval_bar_comparison.png
  plots/eval_trajectories.png
  plots/eval_reward_distribution.png

-----------------------------------------------------------------------
PART B: OBSERVATION ENGINEERING  (env/f1_env.py)
-----------------------------------------------------------------------

── BEFORE: 6D observation ──────────────────────────────────────────────
  [0] v / 20.0
  [1] heading_error / π
  [2] lateral_error / 3.0
  [3] sin(heading_error)
  [4] cos(heading_error)
  [5] curv_near / π    (5 waypoints ahead ≈ 0.5 s)

── AFTER: 11D observation ──────────────────────────────────────────────
  [0]  v / 20.0            (same)
  [1]  heading_error / π   (same)
  [2]  lateral_error / 3.0 (same)
  [3]  sin(heading_error)  (same)
  [4]  cos(heading_error)  (same)
  [5]  curv_near / π    5  waypoints ahead  ≈ 0.5 s  (same)
  [6]  curv_mid  / π   15  waypoints ahead  ≈ 1.5 s  ← NEW
  [7]  curv_far  / π   30  waypoints ahead  ≈ 3.0 s  ← NEW
  [8]  progress          lap position ∈ [0, 1]        ← NEW
  [9]  v_y / 5.0         lateral sliding velocity     ← NEW (Part A)
  [10] r   / 2.0         yaw rate                     ← NEW (Part A)

WHY MULTIPLE CURVATURE SAMPLES?
  At 19 m/s, 5 waypoints ≈ 0.5 seconds of lookahead.
  One curvature sample tells you what to do RIGHT NOW — not enough
  to plan a braking point for a corner that starts in 2 seconds.

  Three samples give the agent a "radar" view of the track:
    curv_near → act now
    curv_mid  → prepare (is the next corner just starting?)
    curv_far  → strategy (is there a long straight coming?)

  Real F1 engineers give the car this kind of lookahead via track maps
  and sector profiles. We approximate it with 3 angle differences.

WHY LAP PROGRESS?
  Without it, the agent has no sense of WHERE it is on the circuit.
  It can't learn "always brake early at this corner" because it doesn't
  know which corner it's at.
  progress = idx / len(track) ∈ [0.0, 1.0] is a compact position signal.

WHY v_y AND r?
  These are ONLY meaningful with DynamicCar (Part A).
  In the kinematic model, v_y = 0 always (no lateral slip by definition).
  With DynamicCar, v_y > 0 means the rear is sliding outward.
  Without these in the obs, the agent cannot detect a developing spin.

-----------------------------------------------------------------------
PART A: DYNAMIC BICYCLE MODEL  (env/car_model.py — DynamicCar)
-----------------------------------------------------------------------

── WHAT CHANGED vs kinematic Car ───────────────────────────────────────

  Kinematic Car (OLD):
    State: [x, y, yaw, v]  — 4 states
    Physics: car always moves exactly where it points
    Turning: yaw_rate = v / wheelbase * tan(steer)
    No lateral dynamics, no tyre slip

  DynamicCar (NEW):
    State: [x, y, psi, v_x, v_y, r]  — 6 states
    Physics: car CAN slide sideways; tyres generate lateral force
    Turning: governed by tyre forces via Pacejka model
    Lateral dynamics: v_y and r evolve via Newton's laws

── NEW PHYSICS CONCEPTS ────────────────────────────────────────────────

  TYRE SLIP ANGLE (α):
    The difference between where the tyre POINTS and where it MOVES.

    At small speeds with gentle steering: α ≈ 0. Tyres grip.
    In a hard corner at high speed: α grows. Tyres start sliding.

    Front slip angle:  α_f = δ - arctan( (v_y + a·r) / v_x )
    Rear slip angle:   α_r =   - arctan( (v_y - b·r) / v_x )

    Where:
      δ = steering angle (rad)
      a = front axle to CoM distance (1.3 m)
      b = rear axle to CoM distance (1.2 m)
      v_x = forward speed, v_y = lateral speed, r = yaw rate

  PACEJKA MAGIC FORMULA:
    F_y = D · sin( C · arctan( B · α ) )

    D = peak force = μ · F_z        (grip scales with tyre load)
    C = shape factor = 1.3          (how sharp is the peak?)
    B = stiffness factor            (chosen so BCD = cornering stiffness)

    Behaviour:
      small α → F_y ≈ C_tyre · α   (linear — tyres gripping)
      peak α  → F_y = D = μ · F_z  (maximum lateral force)
      large α → F_y drops           (tyre saturating — sliding)

    This is the famous "tyre curve" — every motorsport engineer knows it.
    It means you can push the car to its limit, but past the peak the
    grip DROPS, making recovery harder. This is oversteer in practice.

  EQUATIONS OF MOTION:
    m · v_x_dot = F_drive - F_drag - F_yf · sin(δ)
    m · (v_y_dot + v_x · r) = F_yf · cos(δ) + F_yr
    I_z · r_dot = a · F_yf · cos(δ) - b · F_yr

    The v_x · r term is the Coriolis acceleration (centripetal force)
    — it's what makes you "feel" the G-force in a corner.

── BACKWARD COMPATIBILITY ──────────────────────────────────────────────
  DynamicCar exposes:
    .yaw  property → aliases .psi      (old Car used .yaw)
    .v    property → sqrt(v_x² + v_y²) (old Car had scalar .v)
    .reset(yaw=..., v=...)             (accepts old parameter names too)

  Because of these aliases, none of the existing environment code
  (f1_env.py, expert_driver.py, collect_data.py) needed any changes
  to the existing call sites. Only the car instantiation and the
  new obs dimensions were changed.

── PARAMETERS CHOSEN ───────────────────────────────────────────────────
  m = 750 kg        F1 car ~798 kg with driver
  I_z = 1200 kg·m²  yaw inertia — how "resistant" to spinning
  a = 1.3 m         front axle distance (front-heavy for turn-in)
  b = 1.2 m         rear axle distance
  C_f = C_r = 80,000 N/rad  cornering stiffness — F1 slicks are stiff
  μ = 1.5           peak friction — F1 compound rubber achieves 1.5-2.0
  max_steer = 20°   F1 cars use much less steering than road cars
  max_accel = 15 m/s²  F1 accelerates at ~15g longitudinally
  max_decel = 20 m/s²  F1 brakes are EXTREMELY powerful

-----------------------------------------------------------------------
BC WEIGHT TRANSFER — AUTO-DETECTED DIMENSIONS
-----------------------------------------------------------------------

bc_init_policy.py was updated to auto-detect state_dim from saved weights:

  OLD (HARDCODED):
    bc = BCPolicy(state_dim=6, action_dim=2)

  NEW (AUTO-DETECTED):
    ckpt = torch.load(bc_path, ...)
    state_dim  = ckpt["net.0.weight"].shape[1]   # 11 after Part B+A
    action_dim = ckpt["net.4.weight"].shape[0]   # always 2
    bc = BCPolicy(state_dim=state_dim, action_dim=action_dim)

Why auto-detect?
  If you add more obs dimensions in a future session, you don't need
  to update this file. The BC path encodes the architecture in its
  weights, so just read it from there. DRY principle.

Same pattern applied in evaluate.py's make_bc_policy().

-----------------------------------------------------------------------
TRAINING RESULTS
-----------------------------------------------------------------------

Expert data collection: 50 episodes → 36,456 samples, shape (36456, 11)
  (Many episodes crashed on random starts — DynamicCar is harder to
   control than kinematic model. The successful episodes provide clean data.)

BC training: 30 epochs, final loss = 0.0039
  (Converged cleanly. 11D input → [128, ReLU, 128, ReLU] → 2D output)

PPO BC weight transfer verification:
  policy_net[0]: shape [128, 11]  max_diff = 0.00e+00  ✓  (input is now 11D)
  policy_net[2]: shape [128, 128] max_diff = 0.00e+00  ✓
  action_net:    shape [2, 128]   max_diff = 0.00e+00  ✓

PPO stable training (300k steps):
  Starting: ep_rew_mean ≈ 26, speed ≈ 13 m/s  (BC init is already good)
  Final:    ep_rew_mean ≈ 500-590, speed ≈ 20-23 m/s

-----------------------------------------------------------------------
EVALUATION RESULTS (20 episodes per policy)
-----------------------------------------------------------------------

  Policy               Lap%    Reward   Speed(m/s)  LatErr(m)  Laps
  ─────────────────────────────────────────────────────────────────
  Expert (rule)       25.0%     435.2       7.85      1.529    2.75
  BC (imitation)      35.0%     616.8 ←     8.87      1.369    3.85 ←
  PPO + BC + Stable    0.0%     118.1      13.97 ←    1.013 ←  0.95
  ─────────────────────────────────────────────────────────────────
  ← = best in column

NOTE: PPO Scratch (v2) removed from comparison — trained on old 6D obs,
incompatible with DynamicCar 11D env. Cold-start result is in d11.txt.

-----------------------------------------------------------------------
RESULT ANALYSIS
-----------------------------------------------------------------------

The DynamicCar is significantly harder to master than the kinematic model.
Key observations:

1. BC IS NOW THE BEST OVERALL POLICY (35% lap, 616 reward, 3.85 laps)
   This is new. In d11 with kinematic physics, BC tied the expert.
   With dynamic physics, BC generalises better because it learned from
   expert demonstrations that inherently include stable, controlled driving.
   The expert driver is slower (7.85 m/s vs 8.87 m/s) but also less smooth —
   it doesn't adapt to the tyre slip the DynamicCar introduces.

2. PPO IS FASTEST BUT CRASHES (13.97 m/s, 0% lap completion, 0.95 laps)
   PPO learned to drive fast (nearly 2x the expert speed on DynamicCar).
   It also has the BEST lateral precision (1.013 m error).
   But it crashes before completing even one full lap in most episodes.

   WHY? The "go fast" strategy that worked with kinematic physics
   now runs into real tyre physics. At 14+ m/s with sharp corrections,
   the rear slip angle (α_r) grows into the saturation zone of the
   Pacejka curve. The tyre LOSES grip → the car spins → termination.

   This is exactly what the DynamicCar was designed to reveal.
   The agent needs more training time (or curriculum) to learn to
   feel the tyre slip (v_y, r) and back off before reaching saturation.

3. THE 0.95 LAP AVERAGE FOR PPO IS MISLEADING
   Average laps = 0.95 means the agent almost completes one lap on
   average before crashing. It IS making meaningful progress around
   the circuit — just not surviving to the finish. The v_y and r
   signals are there in the obs; 300k steps wasn't enough to fully
   exploit them for stability at high speed.

4. BENCHMARK DEGRADED vs d11 — EXPECTED
   d11 results (kinematic, 6D): PPO 19.4 m/s, 10.75 laps, 1807 reward
   d12 results (dynamic, 11D):  PPO 13.97 m/s, 0.95 laps, 118 reward

   This is NOT a regression — it means the physics model is harder.
   A policy that scores 118 reward under realistic tyre slip is more
   impressive than 1807 reward under perfect-traction kinematic physics.
   The baseline has gone up, not the policy down.

-----------------------------------------------------------------------
KEY ML CONCEPTS LEARNED THIS SESSION
-----------------------------------------------------------------------

1. Multi-step lookahead as observation engineering
   Adding curvature at 3 distances (5, 15, 30 wpts) gives the agent
   a "radar horizon." The agent can start braking for a corner that
   appears in curv_mid before it shows up in curv_near.
   Analogy: human drivers look far down the road, not just the hood.

2. Dynamic vs kinematic bicycle model
   Kinematic: 4 states, no slip, always grippy, unrealistically easy.
   Dynamic: 6 states, Pacejka tyre forces, real oversteer/understeer.
   The kinematic model lets agents cheat with aggressive maneuvers
   that would destabilize a real car. The dynamic model prevents this.

3. Pacejka "Magic Formula" — industry standard tyre model
   F_y = D · sin(C · arctan(B · α))
   Peak force at moderate slip angle; force DROPS at large slip angles.
   This creates the instability that all real racing drivers must learn to manage.

4. Backward compatibility via property aliases
   DynamicCar.yaw = property that returns self.psi
   DynamicCar.v   = property that returns sqrt(v_x² + v_y²)
   This lets us swap physics models without changing any calling code.
   "Open-closed principle": open for extension, closed for modification.

5. Auto-detecting architecture from saved weights
   ckpt["net.0.weight"].shape[1] == input_dim
   This is a general pattern for making utilities robust to future changes.
   Reading the architecture from the artifact means you never have magic
   numbers scattered through your code.

6. Harder physics → longer training required
   300k steps was enough for kinematic PPO. For dynamic PPO, the agent
   needs to learn a new skill: reading v_y and r to prevent spins.
   This is analogous to teaching a human driver — physics simulators
   require longer training before the policy stabilises.

-----------------------------------------------------------------------
WEEK 3 STATUS
-----------------------------------------------------------------------
COMPLETED:
  ✅ Part B: 3-curvature lookahead + lap progress obs (d12)
  ✅ Part A: DynamicCar with Pacejka tyre model (d12)
  ✅ Re-collected expert data on DynamicCar (36k samples, 11D)
  ✅ Retrained BC on 11D obs (loss = 0.0039)
  ✅ Retrained PPO stable on DynamicCar (speed 13.97 m/s at 300k steps)

PENDING (Week 3 continuation):
  → Train longer (1M+ steps) for PPO to master tyre slip
  → Option C: Multi-lap training / lap-aware reward
  → Option D: Curriculum learning — start at slow speed, gradually increase
